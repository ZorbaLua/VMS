%
% Layout retirado de http://www.di.uminho.pt/~prh/curplc09.html#notas
%
\documentclass{report}
\usepackage[portuges]{babel}
\usepackage[utf8]{inputenc}
\usepackage[latin1]{inputenc}

\usepackage{url}
\usepackage{enumerate}

%\usepackage{alltt}
%\usepackage{fancyvrb}
\usepackage{listings}
%LISTING - GENERAL
\lstset{
	basicstyle=\small,
	numbers=left,
	numberstyle=\tiny,
	numbersep=5pt,
	breaklines=true,
    frame=tB,
	mathescape=true,
	escapeinside={(*@}{@*)}
}

\usepackage{xspace}

\parindent=0pt
\parskip=2pt

\setlength{\oddsidemargin}{-1cm}
\setlength{\textwidth}{18cm}
\setlength{\headsep}{-1cm}
\setlength{\textheight}{23cm}

\def\darius{\textsf{Darius}\xspace}
\def\antlr{\texttt{AnTLR}\xspace}
\def\pe{\emph{Publicação Eletrónica}\xspace}

\def\titulo#1{\section{#1}}
\def\supers#1{{\em Supervisores: #1}\\ }
\def\area#1{{\em \'{A}rea: #1}\\[0.2cm]}
\def\resumo{\underline{Resumo}:\\ }


%%%%\input{LPgeneralDefintions}

\title{Projeto (3º ano de LCC)\\ \textbf{VMS, Simular Visual para a máquina de Stack Virtual VM}\\ Relatório de Desenvolvimento}
\author{Adriano Campinho\\ (a79032) \and Vasco Leitão\\ (a79220) }
\date{\today}

\begin{document}

\maketitle
\begin{abstract}
	\quad O objetivo principal deste relatório técnico revolve em explicar e esclarecer os passos
	que os alunos comprometeram neste projecto e as pretendidas resoluções
	para cada problema exposto no enunciado fornecido. \\
	\\
	\\
	\\
  \\
	\supers{Pedro Rangel Henriques e José João}
	\area{Processamento de Linguagens}

\end{abstract}

\tableofcontents

\chapter{Introdução} \label{intro}

\quad Nos últimos anos, temos usado nas disciplinas de Processamento de Linguagens (e
Compiladores) a máquina virtual VM, uma máquina de stack que suporta inteiros, reais e
strings e tem uma heap para permitir um uso dinâmico da memória (necessário por exemplo
para implementar listas ligadas). A VM é programada em Assembly e que disponibiliza um
conjunto de instruções máquina mínimo e muito compreensível, o que a torna
pedagogicamente muito relevante como máquina objeto (destino) em tarefas de compilação.
\\
\\
\quad Para que o uso da VM seja realmente um bom instrumento de trabalho nestes cursos, é
fundamental que exista um simulador que permita testar (de preferência passo a passo) o
código gerado. Atualmente existe, como é de conhecimento de todos, um Assembler para
traduzir o Assembly produzido numa lista de códigos máquina e existe um interpretado que
executa esse código e que fornece uma interface visual que permite acompanhar a execução
verificando a evolução dos vários blocos de memória e dos registo de controlo da máquina.
\\
\\
\quad Esta versão, codificada em Java, está funcional e pode ser usada, mas tem alguns problemas de
implementação, nomeadamente o elevado tempo de execução, quando os programas
aumentam um pouco.
\\
\\
\quad Neste projeto pretende-se que os alunos reconstruam o simulador com interface interativo e
visual para a máquina VM desde o início, em Java ou em C (conforme preferência do grupo)
produzindo um executável que evite os problemas atuais.

\chapter{Análise e Especificação} \label{ae}
\section{Descrição informal da Organização da Máquina}

\quad Trata-se duma máquina de pilhas (por oposição às máquinas de registos),...



Esta e composta pelas seguintes 4 pilhas:
\paragraph{\quad Code}
Esta pilha contem www www www www www www www www www www www www www www www www www www www www www www
\paragraph{\quad OPStack}
Esta pilha contem www www www www www www www www www www www www www www www www www www www www www www
\paragraph{\quad Heap}
Esta pilha contem www www www www www www www www www www www www www www www www www www www www www www
\paragraph{\quad Call Stack}
Esta pilha contem www www www www www www www www www www www www www www www www www www www www www www
\\
\\
\quad A pilha de execução contém valores, que podem ser inteiros, reais ou endereços.
As duas heaps contêm, respetivamente, cadeias de caracteres (strings) e blocos estruturados.
Cada um destes tipos de dados é referenciado por endereços. Cada bloco
estruturado contem um certo número de valores (do mesmo tipo dos valores que se podem
encontrar na pilha).
Um endereço pode apontar para quatro tipos de informação: para código, para a
pilha, para um bloco estruturado ou para uma string.
Ao longo da execução do programa são guardados os seguintes quatro registos
\begin{itemize}
	\item \textit{\textbf{SP}} (Stack Pointer) o registo aponta para o topo corrente da pilha/ para a primeira célula livre da pilha.
	\item \textit{\textbf{FP}} (Frame Pointer) o registo aponta para o endereço de base das variáveis locais.
	\item \textit{\textbf{GP}} (Global Pointer) o registo contem o endereço de base das variáveis globais.
	\item \textit{\textbf{PC}} (Program Counter) o registo aponta para a instrução corrente (da zona de código) por executar.
\end{itemize}

A pilha de chamada permite guardar as chamadas: contém pares de apontadores
(i, f). O endereço i guarda o registo de instrução pc e f o registo fp.

\subsubsection{Instruções}

\quad As instruções são designadas por um nome e podem aceitar um ou dois parâmetros. Estes podem ser:
\begin{itemize}
\item Constantes inteiras,
\item Constantes reais,
\item Cadeias de caracteres delimitadas por aspas. Estas cadeias de caracteres seguem as
mesmas regras de formatação que as cadeias da linguagem C (em particular no que
diz respeito aos caracteres especiais como \", \n ou \\ ),
\item Uma etiqueta simbólica designando uma zona no código.
\end{itemize}

\quad O conjunto da maioria das intrucoes pode ser encontrado no relatorio ...
A estas foram adicionadas

\section{Especificação do Requisitos}
Os requesitos deste projeto podem ser divididos em 3 grandes grupos:
\subsection{Parser}
\subsection{Processador}
\subsection{Interface}

\chapter{Concepção/desenho da Resolução}
\subsection{Parser}
\subsection{Processador}
\subsection{Interface}

\chapter{Guia de Utilização e Testes}
\section{Modo de utilização}
\quad O projeto desenvolvido, tem 3 modos de utilização, estes são:
\paragraph{\quad Máquina em Modo Silencioso}
\paragraph{\quad Máquina em Modo Debug}
\paragraph{\quad Máquina em Modo Interface}
\section{Alternativas, Decisões e Problemas de Implementação}
\section{Testes realizados e Resultados}
Mostram-se a seguir alguns testes feitos (valores introduzidos) e
os respectivos resultados obtidos:

\chapter{Conclusão} \label{concl}
Conclusão e não conclusão da conclusão

\bibliographystyle{alpha}
\bibliography{relprojLayout}

\end{document}
